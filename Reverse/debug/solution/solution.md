定位是一道中等难度的题目。

在反调试方面主要用到了debug blocker这一技术，这一技术的原理以及破解在《逆向工程核心原理》第57章中有非常详细的讲解。

![](D:\文档\理科文档\实验室\出题\2020校赛\final\debug\solution\Snipaste_2020-06-06_16-13-07.png)

由于出题人水平有限，这道题使用的debug blocker实现与逆向工程原理中讲解的基本相同。因此接下来的writeup只会重点介绍子进程核心算法以及父进程的解密算法

在od里进行调试，正常情况下会进入父进程，经过几个分支判断过后，可以看到以下代码

![](D:\文档\理科文档\实验室\出题\2020校赛\final\debug\solution\Snipaste_2020-06-06_16-29-55.png)

在这一段代码中，父进程对某段区域的数据进行了异或解密。如果动态调试时记下了函数的参数，可以发现这段代码对地址`0x401050` 起始、长为`0x28`的区域进行了异或`0x7fd`的操作，我们可以手动恢复。

恢复过后的这段代码显然就是关键的子进程代码

![](D:\文档\理科文档\实验室\出题\2020校赛\final\debug\solution\Snipaste_2020-06-06_16-36-49.png)

代码逻辑也非常清楚，分别加载了两个字符串作为注册表路径和注册表项(注意加载的第二个字符串又异或了`0x30`才是注册表项),然后从所对应的注册表项中尝试读取值，成功的话再与预先声明的一串字符异或一次，即可输出flag(给出flag格式为`actf{}`的话，可以逆向求出注册表的值)

这里在加载字符串的时候使用`loadstring`函数，所以需要动态调试，也就是过掉debug blocker，或者可以使用resource hacker根据资源号查找载入的字符串（思路来自init师傅）

也就是我们只需要在对应的路径下建立对应的注册表项即可拿到flag

![](D:\文档\理科文档\实验室\出题\2020校赛\final\debug\solution\Snipaste_2020-06-06_16-54-41.png)